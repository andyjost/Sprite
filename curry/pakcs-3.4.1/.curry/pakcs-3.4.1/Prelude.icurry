interface Prelude where {
infixl 3 <|>;
infixl 4 <*>;
infixl 4 *>;
infixl 4 <*;
infix 4 ===;
infix 4 ==;
infix 4 /=;
infixl 7 /;
infixl 4 <$;
infixl 7 `div`;
infixl 7 `mod`;
infixl 7 `quot`;
infixl 7 `rem`;
infixl 1 >>=;
infixl 1 >>;
infixl 6 +;
infixl 6 -;
infixl 7 *;
infix 4 <;
infix 4 >;
infix 4 <=;
infix 4 >=;
infixr 0 $;
infixr 0 $!;
infixr 0 $!!;
infixr 0 $#;
infixr 0 $##;
infixr 0 &;
infixr 3 &&;
infixr 0 &>;
infixr 5 ++;
infixr 9 .;
infix 4 /==;
infixl 4 <$>;
infix 4 =:<<=;
infix 4 =:<=;
infix 4 =:=;
infixr 0 ?;
infix 4 `elem`;
infix 4 `notElem`;
infixr 0 `seq`;
infixr 2 ||;
class Applicative a => (Alternative :: * -> *) a {
  empty :: a b;
  (<|>) :: a b -> a b -> a b;
  some 1 :: a b -> a [b];
  many 1 :: a b -> a [b]
};
class Functor a => (Applicative :: * -> *) a {
  pure :: b -> a b;
  (<*>) 0 :: a (b -> c) -> a b -> a c;
  (*>) 2 :: a b -> a c -> a c;
  (<*) 0 :: a b -> a c -> a b;
  liftA2 2 :: (b -> c -> d) -> a b -> a c -> a d
};
data Bool = False | True;
class Bounded a {
  minBound :: a;
  maxBound :: a
};
data Char;
type DET a = a;
class Data a {
  (===) :: a -> a -> Bool;
  aValue :: a
};
data Either a b = Left a | Right b;
class Enum a {
  succ 0 :: a -> a;
  pred 0 :: a -> a;
  toEnum :: Int -> a;
  fromEnum :: a -> Int;
  enumFrom 1 :: a -> [a];
  enumFromThen 2 :: a -> a -> [a];
  enumFromTo 2 :: a -> a -> [a];
  enumFromThenTo 3 :: a -> a -> a -> [a]
};
class Eq a {
  (==) 2 :: a -> a -> Bool;
  (/=) 2 :: a -> a -> Bool
};
type FilePath = [Char];
data Float;
class Fractional a => Floating a {
  pi :: a;
  exp :: a -> a;
  log :: a -> a;
  sqrt 1 :: a -> a;
  (**) 2 :: a -> a -> a;
  logBase 2 :: a -> a -> a;
  sin :: a -> a;
  cos :: a -> a;
  tan 1 :: a -> a;
  asin :: a -> a;
  acos :: a -> a;
  atan :: a -> a;
  sinh :: a -> a;
  cosh :: a -> a;
  tanh 1 :: a -> a;
  asinh :: a -> a;
  acosh :: a -> a;
  atanh :: a -> a
};
class Num a => Fractional a {
  (/) 2 :: a -> a -> a;
  recip 1 :: a -> a;
  fromFloat :: Float -> a
};
class (Functor :: * -> *) a {
  fmap :: (b -> c) -> a b -> a c;
  (<$) 0 :: b -> a c -> a b
};
data IO a;
data IOError
  = IOError [Char]
  | UserError [Char]
  | FailError [Char]
  | NondetError [Char];
data Int;
class (Enum a, Real a) => Integral a {
  div 2 :: a -> a -> a;
  mod 2 :: a -> a -> a;
  quot 2 :: a -> a -> a;
  rem 2 :: a -> a -> a;
  divMod :: a -> a -> (a, a);
  quotRem :: a -> a -> (a, a);
  toInt :: a -> Int
};
data Maybe a = Nothing | Just a;
class Applicative a => (Monad :: * -> *) a {
  (>>=) :: a b -> (b -> a c) -> a c;
  (>>) 2 :: a b -> a c -> a c;
  return 0 :: b -> a b
};
class Monad a => (MonadFail :: * -> *) a {
  fail :: [Char] -> a b
};
class Monoid a {
  mempty :: a;
  mappend :: a -> a -> a;
  mconcat 0 :: [a] -> a
};
class Num a {
  (+) :: a -> a -> a;
  (-) 2 :: a -> a -> a;
  (*) :: a -> a -> a;
  negate 1 :: a -> a;
  abs :: a -> a;
  signum :: a -> a;
  fromInt :: Int -> a
};
class Eq a => Ord a {
  compare 2 :: a -> a -> Ordering;
  (<) 2 :: a -> a -> Bool;
  (>) 2 :: a -> a -> Bool;
  (<=) 2 :: a -> a -> Bool;
  (>=) 2 :: a -> a -> Bool;
  min 2 :: a -> a -> a;
  max 2 :: a -> a -> a
};
data Ordering = LT | EQ | GT;
class Read a {
  readsPrec :: Int -> [Char] -> [(a, [Char])];
  readList 0 :: [Char] -> [([a], [Char])]
};
type ReadS a = [Char] -> [(a, [Char])];
class (Num a, Ord a) => Real a {
  toFloat :: a -> Float
};
class (Fractional a, Real a) => RealFrac a {
  properFraction :: Integral b => a -> (b, a);
  truncate 1 :: Integral b => a -> b;
  round 1 :: Integral b => a -> b;
  ceiling 1 :: Integral b => a -> b;
  floor 1 :: Integral b => a -> b
};
class Show a {
  show 1 :: a -> [Char];
  showsPrec 3 :: Int -> a -> [Char] -> [Char];
  showList 0 :: [a] -> [Char] -> [Char]
};
type ShowS = [Char] -> [Char];
type String = [Char];
type Success = Bool;
(!!) 2 :: [a] -> Int -> a;
($) 2 :: (a -> b) -> a -> b;
($!) 2 :: (a -> b) -> a -> b;
($!!) 2 :: (a -> b) -> a -> b;
($#) 2 :: (a -> b) -> a -> b;
($##) 2 :: (a -> b) -> a -> b;
(&) 2 :: Bool -> Bool -> Bool;
(&&) 2 :: Bool -> Bool -> Bool;
(&>) 2 :: Bool -> a -> a;
(++) 2 :: [a] -> [a] -> [a];
(.) 2 :: (a -> b) -> (c -> a) -> c -> b;
(/==) 2 :: Data a => a -> a -> Bool;
(<$>) 0 :: Functor c => (a -> b) -> c a -> c b;
(=:<<=) 2 :: Data a => a -> a -> Bool;
(=:<=) 2 :: Data a => a -> a -> Bool;
(=:=) 2 :: Data a => a -> a -> Bool;
(?) 2 :: a -> a -> a;
PEVAL 1 :: a -> a;
(^) 2 :: (Num a, Integral b) => a -> b -> a;
all 1 :: (a -> Bool) -> [a] -> Bool;
and 0 :: [Bool] -> Bool;
any 1 :: (a -> Bool) -> [a] -> Bool;
anyOf 0 :: [a] -> a;
appendFile 2 :: [Char] -> [Char] -> IO ();
apply 2 :: (a -> b) -> a -> b;
asTypeOf 0 :: a -> a -> a;
break 1 :: (a -> Bool) -> [a] -> ([a], [a]);
catch 2 :: IO a -> (IOError -> IO a) -> IO a;
chr 1 :: Int -> Char;
concat 0 :: [[a]] -> [a];
concatMap 1 :: (a -> [b]) -> [a] -> [b];
cond 2 :: Bool -> a -> a;
const 2 :: a -> b -> a;
constrEq 2 :: a -> a -> Bool;
curry 3 :: ((a, b) -> c) -> a -> b -> c;
doSolve 1 :: Bool -> IO ();
drop 2 :: Int -> [a] -> [a];
dropWhile 2 :: (a -> Bool) -> [a] -> [a];
either 3 :: (a -> b) -> (c -> b) -> Either a c -> b;
elem 1 :: Eq a => a -> [a] -> Bool;
ensureNotFree 1 :: a -> a;
ensureSpine 1 :: [a] -> [a];
error 1 :: [Char] -> a;
even 1 :: Integral a => a -> Bool;
failed 0 :: a;
failure 2 :: a -> b -> c;
filter 2 :: (a -> Bool) -> [a] -> [a];
flip 3 :: (a -> b -> c) -> b -> a -> c;
foldl 3 :: (a -> b -> a) -> a -> [b] -> a;
foldl1 2 :: (a -> a -> a) -> [a] -> a;
foldr 3 :: (a -> b -> b) -> b -> [a] -> b;
foldr1 2 :: (a -> a -> a) -> [a] -> a;
fromIntegral 0 :: (Integral a, Num b) => a -> b;
fst 1 :: (a, b) -> a;
getChar 0 :: IO Char;
getLine 0 :: IO [Char];
groundNormalForm 1 :: a -> a;
head 1 :: [a] -> a;
id 1 :: a -> a;
ifThenElse 3 :: Bool -> a -> a -> a;
ioError 1 :: IOError -> IO a;
isAlpha 1 :: Char -> Bool;
isAlphaNum 1 :: Char -> Bool;
isBinDigit 1 :: Char -> Bool;
isDigit 1 :: Char -> Bool;
isHexDigit 1 :: Char -> Bool;
isLower 1 :: Char -> Bool;
isOctDigit 1 :: Char -> Bool;
isSpace 1 :: Char -> Bool;
isUpper 1 :: Char -> Bool;
iterate 2 :: (a -> a) -> a -> [a];
length 1 :: [a] -> Int;
letrec 2 :: a -> a -> Bool;
lex 1 :: [Char] -> [([Char], [Char])];
liftM2 3 :: Monad d => (a -> b -> c) -> d a -> d b -> d c;
lines 1 :: [Char] -> [[Char]];
lookup 2 :: Eq a => a -> [(a, b)] -> Maybe b;
map 2 :: (a -> b) -> [a] -> [b];
mapM 1 :: Monad b => (a -> b c) -> [a] -> b [c];
mapM_ 1 :: Monad b => (a -> b c) -> [a] -> b ();
maybe 3 :: a -> (b -> a) -> Maybe b -> a;
normalForm 1 :: a -> a;
not 1 :: Bool -> Bool;
notElem 1 :: Eq a => a -> [a] -> Bool;
null 1 :: [a] -> Bool;
odd 0 :: Integral a => a -> Bool;
or 0 :: [Bool] -> Bool;
ord 1 :: Char -> Int;
otherwise 0 :: Bool;
print 0 :: Show a => a -> IO ();
putChar 1 :: Char -> IO ();
putStr 1 :: [Char] -> IO ();
putStrLn 1 :: [Char] -> IO ();
read 1 :: Read a => [Char] -> a;
readFile 1 :: [Char] -> IO [Char];
readParen
2
::
Bool -> ([Char] -> [(a, [Char])]) -> [Char] -> [(a, [Char])];
reads 0 :: Read a => [Char] -> [(a, [Char])];
realToFrac 0 :: (Real a, Fractional b) => a -> b;
repeat 1 :: a -> [a];
replicate 2 :: Int -> a -> [a];
reverse 0 :: [a] -> [a];
seq 2 :: a -> b -> b;
sequence 1 :: Monad a => [a b] -> a [b];
sequence_ 0 :: Monad a => [a b] -> a ();
showChar 0 :: Char -> [Char] -> [Char];
showParen 2 :: Bool -> ([Char] -> [Char]) -> [Char] -> [Char];
showString 2 :: [Char] -> [Char] -> [Char];
showTuple 1 :: [[Char] -> [Char]] -> [Char] -> [Char];
shows 0 :: Show a => a -> [Char] -> [Char];
snd 1 :: (a, b) -> b;
solve 1 :: Bool -> Bool;
span 2 :: (a -> Bool) -> [a] -> ([a], [a]);
splitAt 2 :: Int -> [a] -> ([a], [a]);
success 0 :: Bool;
tail 1 :: [a] -> [a];
take 2 :: Int -> [a] -> [a];
takeWhile 2 :: (a -> Bool) -> [a] -> [a];
uncurry 2 :: (a -> b -> c) -> (a, b) -> c;
unknown 0 :: Data a => a;
unlines 0 :: [[Char]] -> [Char];
until 3 :: (a -> Bool) -> (a -> a) -> a -> a;
unwords 1 :: [[Char]] -> [Char];
unzip 1 :: [(a, b)] -> ([a], [b]);
unzip3 1 :: [(a, b, c)] -> ([a], [b], [c]);
userError 0 :: [Char] -> IOError;
words 1 :: [Char] -> [[Char]];
writeFile 2 :: [Char] -> [Char] -> IO ();
zip 2 :: [a] -> [b] -> [(a, b)];
zip3 3 :: [a] -> [b] -> [c] -> [(a, b, c)];
zipWith 3 :: (a -> b -> c) -> [a] -> [b] -> [c];
zipWith3 4 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d];
(||) 2 :: Bool -> Bool -> Bool;
instance Alternative [] {
  (<|>) 0;
  empty 0
};
instance Applicative ((->) a) {
  liftA2 4;
  (<*>) 3;
  pure 0
};
instance Applicative [] {
  liftA2 3;
  (*>) 2;
  (<*>) 2;
  pure 1
};
instance Bounded () {
  maxBound 0;
  minBound 0
};
instance (Bounded a, Bounded b) => Bounded (a, b) {
  maxBound 0;
  minBound 0
};
instance (Bounded a, Bounded b, Bounded c) => Bounded (a, b, c) {
  maxBound 0;
  minBound 0
};
instance (Bounded a, Bounded b, Bounded c,
          Bounded d) => Bounded (a, b, c, d) {
  maxBound 0;
  minBound 0
};
instance (Bounded a, Bounded b, Bounded c, Bounded d,
          Bounded e) => Bounded (a, b, c, d, e) {
  maxBound 0;
  minBound 0
};
instance Bounded Bool {
  minBound 0;
  maxBound 0
};
instance Bounded Char {
  maxBound 0;
  minBound 0
};
instance Data () {
  aValue 0;
  (===) 2
};
instance (Data a, Data b) => Data (a, b) {
  aValue 0;
  (===) 2
};
instance (Data a, Data b, Data c) => Data (a, b, c) {
  aValue 0;
  (===) 2
};
instance (Data a, Data b, Data c, Data d) => Data (a, b, c, d) {
  aValue 0;
  (===) 2
};
instance (Data a, Data b, Data c, Data d, Data e) => Data (a, b, c,
                                                           d, e) {
  aValue 0;
  (===) 2
};
instance (Data a, Data b, Data c, Data d, Data e,
          Data f) => Data (a, b, c, d, e, f) {
  aValue 0;
  (===) 2
};
instance (Data a, Data b, Data c, Data d, Data e, Data f,
          Data g) => Data (a, b, c, d, e, f, g) {
  aValue 0;
  (===) 2
};
instance Data a => Data [a] {
  aValue 0;
  (===) 2
};
instance Data Bool {
  (===) 2;
  aValue 0
};
instance Data Char {
  aValue 0;
  (===) 0
};
instance Applicative (Either a) {
  (<*>) 0;
  pure 0
};
instance (Data a, Data b) => Data (Either a b) {
  (===) 2;
  aValue 0
};
instance Enum () {
  enumFromThenTo 3;
  enumFromTo 2;
  enumFromThen 2;
  enumFrom 1;
  fromEnum 1;
  toEnum 1;
  pred 1;
  succ 1
};
instance Enum Bool {
  enumFromThen 2;
  enumFrom 1;
  fromEnum 1;
  toEnum 1;
  pred 1;
  succ 1
};
instance Enum Char {
  enumFromThen 2;
  enumFrom 1;
  fromEnum 0;
  toEnum 0;
  pred 1;
  succ 1
};
instance Eq () {
  (==) 2
};
instance (Eq a, Eq b) => Eq (a, b) {
  (==) 2
};
instance (Eq a, Eq b, Eq c) => Eq (a, b, c) {
  (==) 2
};
instance (Eq a, Eq b, Eq c, Eq d) => Eq (a, b, c, d) {
  (==) 2
};
instance (Eq a, Eq b, Eq c, Eq d, Eq e) => Eq (a, b, c, d, e) {
  (==) 2
};
instance Eq a => Eq [a] {
  (==) 2
};
instance Eq Bool {
  (==) 2
};
instance Eq Char {
  (==) 2
};
instance (Eq a, Eq b) => Eq (Either a b) {
  (==) 2
};
instance Data Float {
  aValue 0;
  (===) 0
};
instance Eq Float {
  (==) 2
};
instance Floating Float {
  atanh 0;
  acosh 0;
  asinh 0;
  tanh 0;
  cosh 0;
  sinh 0;
  atan 0;
  acos 0;
  asin 0;
  tan 0;
  cos 0;
  sin 0;
  sqrt 0;
  log 0;
  exp 0;
  pi 0
};
instance Fractional Float {
  fromFloat 1;
  (/) 2
};
instance Functor ((->) a) {
  fmap 0
};
instance Functor [] {
  fmap 0
};
instance Functor (Either a) {
  fmap 2
};
instance Alternative IO {
  (<|>) 2;
  empty 0
};
instance Applicative IO {
  liftA2 0;
  (<*>) 0;
  (*>) 2;
  pure 0
};
instance Functor IO {
  fmap 2
};
instance Data IOError {
  (===) 2;
  aValue 0
};
instance Eq IOError {
  (==) 2
};
instance Data Int {
  aValue 0;
  (===) 0
};
instance Enum Int {
  enumFromThenTo 3;
  enumFromThen 2;
  enumFromTo 2;
  enumFrom 1;
  fromEnum 1;
  toEnum 1;
  pred 1;
  succ 1
};
instance Eq Int {
  (==) 2
};
instance Integral Int {
  toInt 1;
  quotRem 2;
  divMod 2
};
instance Alternative Maybe {
  (<|>) 2;
  empty 0
};
instance Applicative Maybe {
  liftA2 3;
  (*>) 2;
  (<*>) 2;
  pure 0
};
instance Data a => Data (Maybe a) {
  (===) 2;
  aValue 0
};
instance Eq a => Eq (Maybe a) {
  (==) 2
};
instance Functor Maybe {
  fmap 2
};
instance Monad ((->) a) {
  (>>=) 2
};
instance Monad [] {
  (>>) 0;
  (>>=) 2
};
instance Monad (Either a) {
  (>>=) 2;
  return 0
};
instance Monad IO {
  (>>) 0;
  (>>=) 0
};
instance Monad Maybe {
  (>>) 0;
  (>>=) 2
};
instance MonadFail [] {
  fail 1
};
instance MonadFail IO {
  fail 1
};
instance MonadFail Maybe {
  fail 1
};
instance Monoid () {
  mconcat 1;
  mappend 2;
  mempty 0
};
instance (Monoid a, Monoid b) => Monoid (a, b) {
  mappend 2;
  mempty 0
};
instance (Monoid a, Monoid b, Monoid c) => Monoid (a, b, c) {
  mappend 2;
  mempty 0
};
instance (Monoid a, Monoid b, Monoid c, Monoid d) => Monoid (a, b,
                                                             c, d) {
  mappend 2;
  mempty 0
};
instance (Monoid a, Monoid b, Monoid c, Monoid d,
          Monoid e) => Monoid (a, b, c, d, e) {
  mappend 2;
  mempty 0
};
instance Monoid b => Monoid (a -> b) {
  mappend 3;
  mempty 1
};
instance Monoid [a] {
  mconcat 1;
  mappend 0;
  mempty 0
};
instance Monoid a => Monoid (IO a) {
  mappend 0;
  mempty 0
};
instance Monoid a => Monoid (Maybe a) {
  mappend 2;
  mempty 0
};
instance Num Float {
  fromInt 1;
  signum 1;
  abs 1;
  negate 1;
  (*) 2;
  (-) 2;
  (+) 2
};
instance Num Int {
  fromInt 1;
  signum 1;
  abs 1;
  negate 1;
  (*) 2;
  (-) 2;
  (+) 2
};
instance Ord () {
  (<=) 2
};
instance (Ord a, Ord b) => Ord (a, b) {
  (<=) 2
};
instance (Ord a, Ord b, Ord c) => Ord (a, b, c) {
  (<=) 2
};
instance (Ord a, Ord b, Ord c, Ord d) => Ord (a, b, c, d) {
  (<=) 2
};
instance (Ord a, Ord b, Ord c, Ord d, Ord e) => Ord (a, b, c, d,
                                                     e) {
  (<=) 2
};
instance Ord a => Ord [a] {
  (<=) 2
};
instance Ord Bool {
  (<=) 2
};
instance Ord Char {
  (<=) 2
};
instance (Ord a, Ord b) => Ord (Either a b) {
  (<=) 2
};
instance Ord Float {
  (<=) 2
};
instance Ord Int {
  (<=) 2
};
instance Ord a => Ord (Maybe a) {
  (<=) 2
};
instance Bounded Ordering {
  minBound 0;
  maxBound 0
};
instance Data Ordering {
  (===) 2;
  aValue 0
};
instance Enum Ordering {
  enumFromThen 2;
  enumFrom 1;
  fromEnum 1;
  toEnum 1;
  pred 1;
  succ 1
};
instance Eq Ordering {
  (==) 2
};
instance Monoid Ordering {
  mappend 2;
  mempty 0
};
instance Ord Ordering {
  (<=) 2
};
instance Read () {
  readsPrec 1
};
instance (Read a, Read b) => Read (a, b) {
  readsPrec 1
};
instance (Read a, Read b, Read c) => Read (a, b, c) {
  readsPrec 1
};
instance (Read a, Read b, Read c, Read d) => Read (a, b, c, d) {
  readsPrec 1
};
instance (Read a, Read b, Read c, Read d, Read e) => Read (a, b, c,
                                                           d, e) {
  readsPrec 1
};
instance (Read a, Read b, Read c, Read d, Read e,
          Read f) => Read (a, b, c, d, e, f) {
  readsPrec 1
};
instance Read a => Read [a] {
  readsPrec 1
};
instance Read Bool {
  readsPrec 2
};
instance Read Char {
  readList 1;
  readsPrec 1
};
instance (Read a, Read b) => Read (Either a b) {
  readsPrec 2
};
instance Read Float {
  readsPrec 1
};
instance Read Int {
  readsPrec 1
};
instance Read a => Read (Maybe a) {
  readsPrec 2
};
instance Read Ordering {
  readsPrec 2
};
instance Real Float {
  toFloat 1
};
instance Real Int {
  toFloat 1
};
instance RealFrac Float {
  round 0;
  truncate 0;
  properFraction 1
};
instance Show () {
  showsPrec 2
};
instance (Show a, Show b) => Show (a, b) {
  showsPrec 2
};
instance (Show a, Show b, Show c) => Show (a, b, c) {
  showsPrec 2
};
instance (Show a, Show b, Show c, Show d) => Show (a, b, c, d) {
  showsPrec 2
};
instance (Show a, Show b, Show c, Show d, Show e) => Show (a, b, c,
                                                           d, e) {
  showsPrec 2
};
instance (Show a, Show b, Show c, Show d, Show e,
          Show f) => Show (a, b, c, d, e, f) {
  showsPrec 2
};
instance Show a => Show [a] {
  showsPrec 1
};
instance Show Bool {
  showsPrec 2
};
instance Show Char {
  showList 1;
  showsPrec 2
};
instance (Show a, Show b) => Show (Either a b) {
  showsPrec 2
};
instance Show Float {
  showsPrec 0
};
instance Show IOError {
  show 1
};
instance Show Int {
  showsPrec 0
};
instance Show a => Show (Maybe a) {
  showsPrec 2
};
instance Show Ordering {
  showsPrec 2
}
}