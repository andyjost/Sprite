4/26/2018

- I'm trying to get a simple example compiling fib as a string to work.  It
  appears I need the full Prelude (need "failure," for instance, and surely
  more).

    - I also need "otherwise," but I can work around that for now.

- To get the prelude, I will copy from CMC/runtime/lib.  But there is already a
  Prelude module in the interpreter that defines the built-ins.  I somehow need
  to resolve this.

    - Maybe give the built-ins a special name like _Prelude.  And then merge
      the two with custom code.
    - Or is there an equivalent to 'from _Prelude import *' that I can put in
      the real prelude?  I don't think so, because the Prelude actually
      forward-declares, with "external," the things it expects the
      implementation to provide.

TODO
  - Clean up the name Prelude from system.py
  - Change the name of system.py.  It looks like a Python module, but it is
    really a Curry module.
  - It seems annoying to import _System and then copy everything into the
    Prelude.  All references to _System would need to be updated.  Perhaps it
    would be better to call the _System module Prelude after all, and then 1)
    import it, 2) delete it from interp.modules, 3) import the "real" Prelude,
    and 4) merge the contents.

4/29/2018

- I should split up and rename tests/test_py_target.py.  A lot of things in
  there are not specifically related to the Python backend.  Those are really
  interpreter tests that don't relate the the backend at all.  Furthermore, the
  file is just too big and unweildy.  For now, I'm taking the step to create a
  new file to test Prelude.apply.  I think it would be better to make a
  directory containing interpreter/test_*.py files.

5/1/2018

- I got this explanation regarding flexible/rigid tables from Sergio:

      The meaning of flexible/rigid (it applies ot both a case and a function)
      is whether a variable can be instantiated by a pattern.  Consider the
      following program:

        mynot x  = case x of {True -> False; False -> True}
        main = mynot x where x free

      Since the case is rigid the evaluation of main suspends.

      However, if you replace "case" with "fcase" the evaluation of main
      produces both False and True because x is bound to True and False,
      respectively.

5/2/2018

- I fixed an error in the icurry _Base class.  There were comparison methods,
  but no hash.  I took a while to track that one down.
- I'm working on adding support for ICurry BTables.  I got down to the place
  in function_compiler.py where the BTable just needs to be handled  The code
  will be similar to the code handling ATables.

5/3/2018

- I added the sendMoreMoney cryptarithmetic puzzle.  It is a good test for
  residuation: with residuation it finishes instantly whereas a narrowing
  strategy exhausts all memory.  Sergio suggests the following implementation:

      In a flex case, you have code to instantiate a variable.  In a rigid
      case, you could have code to put the expression at the end of the queue.
      If in the queue you have only expressions that were put there for this
      reason, the program suspends.

5/5/2018

- I finished up the BTable code in function_compiler.py.  The BTables can be
  compiled and run.
- I refactored the unit tests.  test_py_target was too big, so I broke it into
  several smaller files for testing interpretation, compiling, and the runtime
  aspects.
- I reworked the isa function a little and added helpers like isa_list and
  isa_tuple.

BUGS:
  - I noticed that test_atable and similar tests are slow even in subsequent
    runs.  I don't think curry2json should be invoked if the .json file already
    exists, so this is unexpected.
  - After I change a .curry file, curry.import_ fails to rerun curry2json.  I
    was using test_atable in test_py_evaluation.py.
  -When curry2json fails, there is no informative error message.

NEXT:
  - I should pare down the prelude so it can be loaded and then try to get the
    fib program working.

5/9/2018

- I started trying to cut down the Prelude, but quickly ran into the issue from
  5/5.  I fixed the importer module so that the JSON is rebuilt when the source
  file is newer.

5/20/2018

- In conversions.py, I'd really like to use Python 3 keyword-only parameters.

      def expr(interp, arg, *args, target=None)

  Maybe it's worth migrating to Python 3 if it's not difficult.

- I need to clean up the typeinfo stuff.  The naming is not consistent.  In
  Interpreter there are things like ti_Failure, but it refers not to the typeinfo, but to the info table.

5/22/2018

- Working on docs and minor fixes that I come across in so doing.

