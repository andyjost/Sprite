'''
Implements a cache for curry-to-ICurry and ICurry-to-JSON conversions.

This cache supplements the filesystem caching in .curry files so that
interactive statements can also be cached.  This exists because the conversions
can be extremely slow depending on the Curry system used and its configuration.
'''

import cPickle as pickle
import cStringIO
import logging
import os
import warnings
from .utility import filesys

logger = logging.getLogger(__name__)

_curry2jsoncache_ = 'uninit' # 'uninit', None (disabled), or sqlite3.Connection.
filename = None

try:
  import sqlite3
except ImportError:
  warnings.warn("Cannot import sqlite3.  Caching is disabled")
  _curry2jsoncache_ = None

def getuserdir():
  '''
  Ensures $HOME/.sprite exists as a readable, writable directory.  Returns it
  as an absolute path.
  '''
  path = os.path.join(os.environ['HOME'], '.sprite')
  return filesys.getdir(path)

def _getdb():
  '''
  Returns an sqlite3.Connection object tied to the curry2json cache file, or
  None.

  The cache file stores the results of curry2icur and curry2json conversions.
  This is used to improve performance, since the conversion to JSON can be very
  slow.  It will be used unless SPRITE_CACHE_FILE is set to the empty string.
  The default cache file is $HOME/.sprite/cache.db.
  '''
  global _curry2jsoncache_
  if _curry2jsoncache_ == 'uninit':
    name = os.environ.get('SPRITE_CACHE_FILE', None)
    if name == '':
      if logger.isEnabledFor(logging.DEBUG):
        logger.debug(
            'Caching is disabled because SPRITE_CACHE_FILE is set to the empty string'
          )
      _curry2jsoncache_ = None
      return
    elif name is None:
      if 'HOME' not in os.environ:
        warnings.warn(
            "HOME is not set in the environment.  The cache at"
            "$HOME/.sprite/cache.db cannot be used."
          )
        _curry2jsoncache_ = None
        return
      name = os.path.join(getuserdir(), 'cache.db')
    _curry2jsoncache_ = sqlite3.connect(name)
    global filename
    filename = name
    if logger.isEnabledFor(logging.DEBUG):
      logger.debug('Using cache file %s' % name)
  return _curry2jsoncache_


class Curry2JsonCache(object):
  '''
  Coordinates one instance of Curry-to-JSON caching.

  Clients create an instance with a pair of Curry and JSON file names in which
  the JSON file needs to be created or updated.  If the result is cached, it
  will be written to the JSON file and this object will evaluate to True.
  Otherwise, the JSON should be generated by other means, after which
  ``update`` should be called to update the cache.
  '''
  def __init__(self, curryfile, jsonfile):
    '''
    Gets the table storing curry2json conversions for the current value of
    TARGET_CURRYPATH in the environment.  Places the JSON for ``curryfile``
    into ``jsonfile`` and makes this object True if it can be found in the
    cache or else makes this object False.
    '''
    self.curryfile = curryfile
    self.db = _getdb()
    self.found = False
    self.jsonfile = jsonfile
    if self.db:
      self.tablename = 'curry2json %s' % os.environ['TARGET_CURRYPATH']
      self.cur = self.db.cursor()
      self.cur.execute(
          '''
          CREATE TABLE IF NOT EXISTS [%s](src TEXT PRIMARY KEY, json TEXT)
          ''' % self.tablename
        )
      self.db.commit()
      self.src = open(self.curryfile).read()
      self.cur.execute(
          '''SELECT json FROM [%s] WHERE src=?''' % self.tablename, (self.src,)
        )
      result = self.cur.fetchone()
      if result:
        dirname = os.path.dirname(jsonfile)
        if not os.path.exists(dirname):
          os.mkdir(dirname)
        with open(jsonfile, 'w') as out:
          assert isinstance(result, tuple) and len(result) == 1
          out.write(result[0].encode('utf-8'))
        self.found = True

  def __nonzero__(self):
    return self.found

  def update(self):
    '''
    Updates the cache with the contents of ``jsonfile``, which are passed to the
    constructor.
    '''
    assert not self.found
    if self.db:
      json = open(self.jsonfile).read()
      self.cur.execute(
          '''INSERT INTO [%s](src, json) VALUES(?, ?)''' % self.tablename
        , (self.src, json)
        )
      self.db.commit()

class ParsedJson(object):
  '''Coordinates one instance of JSON-to-Python caching.'''
  def __init__(self, jsonfile):
    self.db = _getdb()
    self.icur = None
    self.jsonfile = jsonfile
    if self.db:
      self.cur = self.db.cursor()
      self.cur.execute(
          '''
          CREATE TABLE IF NOT EXISTS parsedjson(
              jsonfile TEXT PRIMARY KEY, timestamp INTEGER, pickled BLOB
            )
          '''
        )
      self.db.commit()
      self.cur.execute(
          '''SELECT timestamp, pickled FROM parsedjson WHERE jsonfile=?'''
        , (self.jsonfile,)
        )
      result = self.cur.fetchone()
      if result:
        ts, buf = result
        st = os.stat(self.jsonfile)
        if int(st.st_ctime) == ts:
          self.icur = pickle.load(cStringIO.StringIO(buf))

  def __nonzero__(self):
    return self.icur is not None

  def update(self, icur):
    assert self.icur is None
    if self.db:
      pickled = pickle.dumps(icur, protocol=-1)
      st = os.stat(self.jsonfile)
      self.cur.execute(
          '''INSERT OR REPLACE INTO parsedjson(jsonfile, timestamp, pickled) VALUES(?, ?, ?)'''
        , (self.jsonfile, int(st.st_ctime), sqlite3.Binary(pickled))
        )
      self.db.commit()

