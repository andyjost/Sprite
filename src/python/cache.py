'''
Implements a cache for curry-to-ICurry and ICurry-to-JSON conversions.

This cache supplements the filesystem caching in .curry files so that
interactive statements can also be cached.  This exists because the conversions
can be extremely slow depending on the Curry system used and its configuration.
'''

import cPickle as pickle
import cStringIO
import os
import warnings

_curry2jsoncache_ = 'uninit' # 'uninit', None (disabled), or sqlite3.Connection.

try:
  import sqlite3
except ImportError:
  warnings.warn("Cannot import sqlite3.  Caching is disabled")
  _curry2jsoncache_ = None

def getuserdir():
  '''
  Ensures $HOME/.sprite exists as a readable directory.  Returns it as an
  absolute path.
  '''
  if 'HOME' not in os.environ:
    raise RuntimeError("HOME is not set in the environment.")
  path = os.path.join(os.environ['HOME'], '.sprite')
  if not os.path.exists(path):
    os.mkdir(path)
  elif not os.path.isdir(path):
    raise RuntimeError("%s exists but is not a directory" % path)
  if not os.access(path, os.O_RDONLY):
    raise RuntimeError("%s is not readable" % path)
  return path

def _getdb():
  '''
  Returns an sqlite3.Connection object tied to the curry2json cache file, or
  None.

  The cache file stores the results of curry2icur and curry2json conversions.
  This is used to improve performance, since the conversion to JSON can be very
  slow.  It will be used unless SPRITE_CACHE_FILE is set to the empty string.
  The default cache file is $HOME/.sprite/cache.db.
  '''
  global _curry2jsoncache_
  if _curry2jsoncache_ == 'uninit':
    db = os.environ.get('SPRITE_CACHE_FILE', '')
    if db == '':
      _curry2jsoncache_ = None
      return
    if 'HOME' not in os.environ:
      warnings.warn(
          "HOME is not set in the environment.  The cache at"
          "$HOME/.sprite/cache.db cannot be used."
        )
      _curry2jsoncache_ = None
      return
    if db is None:
      db = os.path.join(getuserdir(), 'cache.db')
    _curry2jsoncache_ = sqlite3.connect(db)
  return _curry2jsoncache_


class Curry2JsonCache(object):
  '''
  Coordinates one instance of Curry-to-JSON caching.

  Clients create an instance with a pair of Curry and JSON file names in which
  the JSON file needs to be created or updated.  If the result is cached, it
  will be written to the JSON file and this object will evaluate to True.
  Otherwise, the JSON should be generated by other means, after which
  ``update`` should be called to update the cache.
  '''
  def __init__(self, curryfile, jsonfile):
    '''
    Gets the table storing curry2json conversions for the current value of
    TARGET_CURRYPATH in the environment.  Places the JSON for ``curryfile``
    into ``jsonfile`` and makes this object True if it can be found in the
    cache or else makes this object False.
    '''
    self.curryfile = curryfile
    self.db = _getdb()
    self.found = False
    self.jsonfile = jsonfile
    if self.db:
      self.tablename = 'curry2json %s' % os.environ['TARGET_CURRYPATH']
      self.cur = self.db.cursor()
      self.cur.execute(
          '''
          CREATE TABLE IF NOT EXISTS [%s](src TEXT PRIMARY KEY, json TEXT)
          ''' % self.tablename
        )
      self.db.commit()
      self.src = open(self.curryfile).read()
      self.cur.execute(
          '''SELECT json FROM [%s] WHERE src=?''' % self.tablename, (self.src,)
        )
      result = self.cur.fetchone()
      if result:
        dirname = os.path.dirname(jsonfile)
        if not os.path.exists(dirname):
          os.mkdir(dirname)
        with open(jsonfile, 'w') as out:
          assert isinstance(result, tuple) and len(result) == 1
          out.write(result[0].encode('utf-8'))
        self.found = True

  def __nonzero__(self):
    return self.found
  
  def update(self):
    '''
    Updates the cache with the contents of ``jsonfile``, which as passed to the
    constructor.
    '''
    assert not self.found
    if self.db:
      json = open(self.jsonfile).read()
      self.cur.execute(
          '''INSERT INTO [%s](src, json) VALUES(?, ?)''' % self.tablename
        , (self.src, json)
        )
      self.db.commit()

class ParsedJson(object):
  '''Coordinates one instance of JSON-to-Python caching.'''
  def __init__(self, jsonfile):
    self.db = _getdb()
    self.icur = None
    self.jsonfile = jsonfile
    if self.db:
      self.cur = self.db.cursor()
      self.cur.execute(
          '''
          CREATE TABLE IF NOT EXISTS parsedjson(
              jsonfile TEXT PRIMARY KEY, timestamp INTEGER, pickled BLOB
            )
          '''
        )
      self.db.commit()
      self.cur.execute(
          '''SELECT timestamp, pickled FROM parsedjson WHERE jsonfile=?'''
        , (self.jsonfile,)
        )
      result = self.cur.fetchone()
      if result:
        ts, buf = result
        st = os.stat(self.jsonfile)
        if int(st.st_mtime) == ts:
          self.icur = pickle.load(cStringIO.StringIO(buf))
    
  def __nonzero__(self):
    return self.icur is not None

  def update(self, icur):
    assert self.icur is None
    if self.db:
      pickled = pickle.dumps(icur, protocol=-1)
      st = os.stat(self.jsonfile)
      self.cur.execute(
          '''INSERT INTO parsedjson(jsonfile, timestamp, pickled) VALUES(?, ?, ?)'''
        , (self.jsonfile, int(st.st_mtime), sqlite3.Binary(pickled))
        )
      self.db.commit()
    
