Sprite unit tests
=================

1. USAGE
--------

        make ['testall' | pattern...]

Use 'make' or 'make testall' to run all tests.  Use 'make test_parse.py' to run
parser tests.


2. FILE LAYOUT
--------------

        data/       Test data files (e.g., sample input, golden results).
        lib/        Test harness code.
        test_*.py   Unit test source code.


3. RUNNING TESTS
----------------

To run the tests, execute the following command:

        run_tests [pattern]

If no pattern is supplied then, unless the test driver is cov_test, the unit
tests will be run.  For cov_test, *all* tests will be run.  Otherwise, the
pattern is a glob that specifies which files to run.  Use the pattern '*.py'
(with quotes) to run all tests.  A few other test runners, each of which uses
this interface, are available:

        run_tests       Run unit tests.
        debug_tests     Run unit tests under gdb.
                        (For debugging C++ code.)
        valgrind_tests  Run unit tests under valgrind.
                        (For debugging memory problems.)
        cov_tests       Run unit tests under coverage.py.
                        (For measuring line coverage.)


4. ORACLE CONFIGURATION
-----------------------

Some tests use an oracle to generate known-good ("golden") results.  To run
these tests, you will need access to another Curry compiler.  The oracle
configuration is found in "tests/oracle".  By default, it searches for "pakcs"
in your path.  You can update this to use another Curry compiler, or, if you
wish to skip these tests, you can simply clear the executable bit from
"tests/oracle".


5. TESTING GUIDELINES
---------------------

Unit tests match the pattern unit_*.py.

  - To run: run_tests 'unit_*.py'
  - The goal of unit testing is line coverage.
	- Every new feature requires a unit test.  Untested features will not be
		accepted into Sprite.
	- Changes that break unit tests will not be accepted.
	- Do not add large-scale or long-running tests to the unit test area.  Large
		tests are almost always inefficient in terms of unique source lines covered
		per unit time.  Unit tests are expected to run very quickly, as they are
		part of the critical inner loop in the edit-build-test development cycle.
	- Use the cov_tests driver to assess the quality of new tests.  New tests
		should increase line coverage with the smallest possible resource footprint
		(time, memory, etc.).

Functional tests match the pattern func_*.py:

  - To run: run_tests 'func_*.py'
	- The goal of functional testing in Sprite is to ensure Curry programs give
		the correct behavior.
	- These tests check the behavior of sample programs against other Curry
		implementations or known results.
	- These tests are allowed to consume more resources than unit tests, but
		should still be made as small as possible.  For instance, to check a
		list-reversal program, it is reasonable to reverse a handful of elements,
		not millions.  These tests are not stress tests and do not need to
		explore the limits of the implementation.


6. EDITOR INTEGRATION
---------------------

A makefile is used to simplify integration with text editors.  For instance, in
vim <Enter> runs "make" by default, so that key can be used to easily run the
tests right from the text editor.

