Module:
-------
  name: assembler
  imports: Prelude

  types:
  ------
    Instruction = Jump | Label
    LabelId = L0 | L1 | L2 | L3 | L4 | L5 | L6 | L7 | L8 | L9

  functions:
  ----------
    assembler:
      $1 <- LHS[1]
      $2 <- LHS[2]
      $3 <- LHS[3]
      case $1 of Prelude.[] -> return (Prelude.[])
                 Prelude.:  -> $4 <- $1[1]
                               $5 <- $1[2]
                               return (assembler.assembler_case_#1 $4 $2 $5 $3)
      return $1
    assembler_case_#1:
      $4 <- LHS[1]
      $2 <- LHS[2]
      $5 <- LHS[3]
      $3 <- LHS[4]
      case $4 of assembler.Jump  -> $6 <- $4[1]
                                    $7 <- IBind
                                    $8 <- IBind
                                    return (assembler.assembler_case_#1_case_#1 $6 $2 $7 $8 $5 $3)
                 assembler.Label -> $9 <- $4[1]
                                    $10 <- IBind
                                    return (assembler.assembler_case_#1_case_#2 $10 $9 $3 $2 $5)
      return $4
    assembler_case_#1_case_#2:
      $10 <- LHS[1]
      $9 <- LHS[2]
      $3 <- LHS[3]
      $2 <- LHS[4]
      $5 <- LHS[5]
      return (assembler.assembler_case_#1_case_#2_case_#1 ((Prelude.=:= $10 ((assembler.insertST $9 $3 $2)))) $10 $9 $3 $2 $5)
    assembler_case_#1_case_#2_case_#1:
      $11 <- LHS[1]
      $10 <- LHS[2]
      $9 <- LHS[3]
      $3 <- LHS[4]
      $2 <- LHS[5]
      $5 <- LHS[6]
      case $11 of Prelude.True  -> return (assembler.assembler $5 $10 $3)
                  Prelude.False -> return (Prelude.failed)
      return $11
    assembler_case_#1_case_#1:
      $6 <- LHS[1]
      $2 <- LHS[2]
      $7 <- LHS[3]
      $8 <- LHS[4]
      $5 <- LHS[5]
      $3 <- LHS[6]
      return (assembler.assembler_case_#1_case_#1_case_#1 ((assembler.lookupST $6 $2 $7 $8)) $6 $2 $7 $8 $5 $3)
    assembler_case_#1_case_#1_case_#1:
      $9 <- LHS[1]
      $6 <- LHS[2]
      $2 <- LHS[3]
      $7 <- LHS[4]
      $8 <- LHS[5]
      $5 <- LHS[6]
      $3 <- LHS[7]
      case $9 of Prelude.True  -> return (Prelude.: 9 ((Prelude.: $7 ((assembler.assembler $5 $8 ((Prelude.+ $3 2)))))))
                 Prelude.False -> return (Prelude.failed)
      return $9
    insertST:
      $1 <- LHS[1]
      $2 <- LHS[2]
      $3 <- LHS[3]
      case $3 of Prelude.[] -> return (Prelude.: ((Prelude.(,) $1 $2)) (Prelude.[]))
                 Prelude.:  -> $4 <- $3[1]
                               $5 <- $3[2]
                               return (assembler.insertST_case_#1 $4 $1 $2 $5)
      return $3
    insertST_case_#1:
      $4 <- LHS[1]
      $1 <- LHS[2]
      $2 <- LHS[3]
      $5 <- LHS[4]
      case $4 of Prelude.(,) -> $6 <- $4[1]
                                $7 <- $4[2]
                                return (assembler.insertST_case_#1_case_#1 $1 $6 $2 $7 $5) ? (assembler.insertST_case_#1_case_#2 $1 $6 $7 $2 $5)
      return $4
    insertST_case_#1_case_#2:
      $1 <- LHS[1]
      $6 <- LHS[2]
      $7 <- LHS[3]
      $2 <- LHS[4]
      $5 <- LHS[5]
      return (assembler.insertST_case_#1_case_#2_case_#1 ((Prelude.=:= ((Prelude.== $1 $6)) (Prelude.False))) $1 $6 $7 $2 $5)
    insertST_case_#1_case_#2_case_#1:
      $8 <- LHS[1]
      $1 <- LHS[2]
      $6 <- LHS[3]
      $7 <- LHS[4]
      $2 <- LHS[5]
      $5 <- LHS[6]
      case $8 of Prelude.True  -> return (Prelude.: ((Prelude.(,) $6 $7)) ((assembler.insertST $1 $2 $5)))
                 Prelude.False -> return (Prelude.failed)
      return $8
    insertST_case_#1_case_#1:
      $1 <- LHS[1]
      $6 <- LHS[2]
      $2 <- LHS[3]
      $7 <- LHS[4]
      $5 <- LHS[5]
      return (assembler.insertST_case_#1_case_#1_case_#1 ((Prelude.& ((Prelude.=:= ((Prelude.== $1 $6)) (Prelude.True))) ((Prelude.=:= $2 $7)))) $1 $6 $2 $7 $5)
    insertST_case_#1_case_#1_case_#1:
      $8 <- LHS[1]
      $1 <- LHS[2]
      $6 <- LHS[3]
      $2 <- LHS[4]
      $7 <- LHS[5]
      $5 <- LHS[6]
      case $8 of Prelude.True  -> return (Prelude.: ((Prelude.(,) $6 $7)) $5)
                 Prelude.False -> return (Prelude.failed)
      return $8
    lookupST:
      $1 <- LHS[1]
      $2 <- LHS[2]
      $3 <- LHS[3]
      $4 <- LHS[4]
      case $2 of Prelude.[] -> return (Prelude.=:= $4 ((Prelude.: ((Prelude.(,) $1 $3)) (Prelude.[]))))
                 Prelude.:  -> $5 <- $2[1]
                               $6 <- $2[2]
                               return (assembler.lookupST_case_#1 $5 $1 $3 $4 $6)
      return $2
    lookupST_case_#1:
      $5 <- LHS[1]
      $1 <- LHS[2]
      $3 <- LHS[3]
      $4 <- LHS[4]
      $6 <- LHS[5]
      case $5 of Prelude.(,) -> $7 <- $5[1]
                                $8 <- $5[2]
                                return (assembler.lookupST_case_#1_case_#1 $1 $7 $3 $8 $4 $6)
      return $5
    lookupST_case_#1_case_#1:
      $1 <- LHS[1]
      $7 <- LHS[2]
      $3 <- LHS[3]
      $8 <- LHS[4]
      $4 <- LHS[5]
      $6 <- LHS[6]
      return (assembler.lookupST_case_#1_case_#1_case_#1 ((Prelude.== $1 $7)) $1 $7 $3 $8 $4 $6)
    lookupST_case_#1_case_#1_case_#1:
      $10 <- LHS[1]
      $1 <- LHS[2]
      $7 <- LHS[3]
      $3 <- LHS[4]
      $8 <- LHS[5]
      $4 <- LHS[6]
      $6 <- LHS[7]
      case $10 of Prelude.True  -> return (Prelude.& ((Prelude.=:= $3 $8)) ((Prelude.=:= $4 ((Prelude.: ((Prelude.(,) $7 $8)) $6)))))
                  Prelude.False -> $9 <- IBind
                                   return (Prelude.& ((assembler.lookupST $1 $6 $3 $9)) ((Prelude.=:= $4 ((Prelude.: ((Prelude.(,) $7 $8)) $9)))))
      return $10
    goal:
      return (assembler.assembler ((Prelude.: ((assembler.Label (assembler.L0))) ((Prelude.: ((assembler.Jump (assembler.L1))) ((Prelude.: ((assembler.Jump (assembler.L0))) ((Prelude.: ((assembler.Label (assembler.L1))) (Prelude.[]))))))))) (Prelude.[]) 0)