============================
Using Sprite Python Bindings
============================

This introduction shows how to interact with the Sprite Curry system via its
Python interface.  It assumes familiarity with Curry.

To get started, invoke the Python executable found at $PREFIX/bin/python.  This
will automatically set up the PYTHONPATH environment variable, making Sprite
available.

The Sprite Curry system is in the ``curry`` module.

  >>> import curry


Using Modules
=============

Curry modules can be loaded from files or defined dynamically.  This section
describes how to work with modules in Sprite.


Loading Curry modules
---------------------

Curry code can be imported into Python using the normal import mechanism.
Curry source files should be imported from ``curry.lib``.

    >>> from curry.lib import Peano

This searches for a file named "Peano.curry" in the paths specified in
``curry.path``.  That list can be modified to update the search paths
dynamically.

    >>> curry.path[:] = ['.']

(Be sure to update this list rather than rebind the variable.  So, assign to a
slice, as shown above, or use methods like ``list.insert`` and ``list.pop``.)

The default value of ``curry.path`` comes from the CURRYPATH environment
variable.  Paths are therein provided as a colon-separated list.

Modules can also be defined dynamically by passing a string to
``curry.compile``.  This has the same effect as importing a Curry source file
with the same content.

    >>> Fib = curry.compile(
    ...   '''
    ...   fib n | n < 3 = 1
    ...         | True  = (fib (n-1)) + (fib (n-2))
    ...   '''
    ... )


Building expressions
--------------------

A loaded Curry module provides a set of definitions.  These appear as
attributes.

    >>> Peano.S
    <curry constructor 'Peano.S'>
    >>> Peano.O
    <curry constructor 'Peano.O'>
    >>> Fib.fib
    <curry function '_interactive_.fib'>

To evaluate Curry code, it is necessary to first build a goal.  The function
``curry.expr`` builds Curry expressions.  There are two ways to use it: the
first is to pass a string containing Curry code.

    >>> goal = curry.expr('add (S (S O)) (S O)')
    >>> print goal
    add (S (S O)) (S O)

The second is to pass ``curry.expr`` a list of Curry symbols and literal
values.

    >>> goal2 = curry.expr([Fib.fib, 7])
    >>> print goal2
    fib 7

Deeper expressions can be constructed by nesting lists.

    >>> print curry.expr([Peano.S, [Peano.S, Peano.O]])
    S (S O)

The ``repr`` of an expression provides more insight into its structure.

    >>> print repr(goal2)
    <fib <Int 7>>

A node is enclosed in angle brackets.  Each consists of a head symbol
followed by zero or more successors (themselves nodes or built-in literals).
There are no special rules for formatting lists, tuples, strings, or anything
else.  In this case, we see clearly that the argument to ``fib`` is a boxed
integer.


Evaluating expressions
----------------------

To evaluate an expression pass it to ``curry.eval``.

    >>> print next(curry.eval(goal))
    S (S (S O))
    >>> print next(curry.eval(goal2))
    13

This returns a generator that yields the values the given goal.  The goal is
evaluated lazily to produce one value each time ``next`` is called.  So if
there are many results but you are only interested in the first one, call
``next`` once and Curry will do the minimum work necessary to compute the first
value.

