=============================
Using Sprite Interactive Mode
=============================

This introduction shows how to use Sprite to interact with Curry via Python.
It assumes familiarity with Curry.

To get started, invoke the Python executable found at $PREFIX/bin/python.  It
automatically sets up the PYTHONPATH environment variable so that Sprite is
available.

The Sprite Curry system is in the ``curry`` module.

  >>> import curry


Using Modules
=============

Sprite lets you interact with Curry modules.  Modules can be loaded from files
or defined dynamically.  This section describes how to work with modules in the
Curry interactive mode.


Loading Curry modules
---------------------

Curry code can be imported into Python using the normal import mechanism.
Curry source files should be imported from ``curry.lib``.

    >>> from curry.lib import Peano

The search path for Curry code is given by ``curry.path``.  This list can be
modified to update the search paths dynamically.

    >>> curry.path[:] = ['.']

(Be sure to update this list rather than rebind the variable.  So, assign to a
slice, as shown above, or use methods like ``list.insert`` and ``list.pop``.)

The default ``curry.path`` comes from the CURRYPATH environment
variable.  It is a colon-separated list of paths.

A module can also be specified as a string.  Compiling a string with
``curry.compile`` has the same effect as importing its definitions from a Curry
source file.

    >>> Fib = curry.compile(
    ...   '''
    ...   fib n | n < 3 = 1
    ...         | True  = (fib (n-1)) + (fib (n-2))
    ...   '''
    ... )


Building expressions
--------------------

A loaded Curry module provides a set of definitions.  These appear as
attributes.

    >>> Peano.S
    <curry constructor 'Peano.S'>
    >>> Peano.O
    <curry constructor 'Peano.O'>
    >>> Fib.fib
    <curry function '_interactive_.fib'>

To evaluate anything, one must first build a goal expression.  This is done
with the help of ``curry.expr``.  There are two ways to use this function.  The first
is to pass a string into ``curry.expr``.

    >>> goal = curry.expr('add (S (S O)) (S O)')
    >>> print goal
    add (S (S O)) (S O)

The second is to pass ``curry.expr`` a list of Curry symbols and literal
values.

    >>> goal2 = curry.expr([Fib.fib, 7])
    >>> print goal2
    fib 7

Deeper expressions can be constructed by nesting lists.

    >>> print curry.expr([Peano.S, [Peano.S, Peano.O]])
    S (S O)

The ``repr`` of an expression provides more insight into its structure.

    >>> print repr(goal2)
    <fib <Int 7>>

A node is enclosed in angle brackets.  Each consists of a head symbol
followed by zero or more successors (themselves nodes or built-in literals).
There are no special rules for formatting lists, tuples, strings, or anything
else.  In this case, we see clearly that the argument to ``fib`` is a boxed
integer.


Evaluating expressions
----------------------

To evaluate an expression pass it to ``curry.eval``.

    >>> print next(curry.eval(goal))
    S (S (S O))
    >>> print next(curry.eval(goal2))
    13

This returns a generator that yields the values the given goal.  The goal is
evaluated lazily to produce one value each time ``next`` is called.  So if
there are many results but you are only interested in the first one, call
``next`` once and Curry will do the minimum work necessary to compute the first
value.

