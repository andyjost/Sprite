============================
Using Sprite Python Bindings
============================

This introduction shows how to interact with the Sprite Curry system via its
Python interface.  It assumes familiarity with Curry.

To get started, invoke the Python executable found at $PREFIX/bin/python.  This
will automatically set up the PYTHONPATH environment variable, making Sprite
available.

The Sprite Curry system is in the ``curry`` module.

  >>> import curry


Using Modules
=============

Curry modules can be loaded from files or defined dynamically.  This section
describes how to work with modules in Sprite.


Loading Curry modules
---------------------

Curry code can be imported into Python using the Python import mechanism.  The
search path for Curry modules can be found in the list variable ``curry.path``.
Its initial value comes by splitting the CURRYPATH environment variable on
colons.  Therefore, one way to load the ``Peano`` module found in the same
directory as this tutorial would be to add this directory to CURRYPATH before
starting Python.  Alternatively, if Python has already been started in this
directory, then the search path can be updated as follows:

    >>> curry.path[:] = ['.']

(Be sure to update the list object rather than rebind the ``curry.path``
variable.  So, use slice assignment, as shown above, or the ``list.insert``
method.)

To import a Curry module, import it relative to ``curry.lib``.

    >>> from curry.lib import Peano

This searches each path in ``curry.path``, in order, until it finds a file
named ``Peano.curry``.

Curry definitions can also be created dynamically by passing a string to
``curry.compile``.  This has the same effect as importing a Curry source file
with the same content.

    >>> Fib = curry.compile(
    ...   '''
    ...   fib n | n < 3 = 1
    ...         | True  = (fib (n-1)) + (fib (n-2))
    ...   '''
    ... )


Building expressions
--------------------

A loaded Curry module provides a set of definitions.  These appear as
attributes.

    >>> Peano.S
    <curry constructor 'Peano.S'>
    >>> Peano.O
    <curry constructor 'Peano.O'>
    >>> Fib.fib
    <curry function '_interactive_.fib'>

To evaluate Curry code, one first builds an expression.  One way to do so is
with the function ``curry.expr``.  This function takes a mixed list of Curry
symbols or literals, and returns a Curry expression:

    >>> goal2 = curry.expr([Fib.fib, 7])
    >>> print goal2
    fib 7

This function automatically converts many Python objects into their Curry
equivalents.  Type ``help(curry.expr)`` at the Python prompt for details.

Nested expressions can be specified with nested lists:

    >>> print curry.expr([Peano.S, [Peano.S, Peano.O]])
    S (S O)

Another way to create expressions is to call ``curry.compile`` with the
``mode`` argument set to 'expr'.  This causes ``compile`` to interpret the
Curry code as an expression rather than a definition:

    >>> goal = curry.compile('add (S (S O)) (S O)', mode='expr', imports=[Peano])
    >>> print goal
    add (S (S O)) (S O)

Since the Curry code in this example uses unqualified names, the Peano module
needs to be listed as an import.

Curry expressions have so far been shown using their string, or ``str``,
representation.  The representation, or ``repr``, provides more insight into
the structure.  (If you are unfamiliar with the difference between these,
consult the Python documentation.)  The following shows the representation of a
Curry expression:

    >>> print repr(goal2)
    <fib <Int 7>>

Each node is now enclosed in angle brackets and node labels are shown.  Every
angle-bracket-enclosed node specifier is either a label followed by zero or
more successors or a literal integer, floating-point number, or character.  The
arguments following a label can be built-ins or angle-enclosed node specifiers.
There are no special rules for formatting lists, tuples, or strings.  In this
above example, we can clearly see that the argument to ``fib`` is a boxed
integer, since the constructor ``Int`` appears before the integer literal
``7``.


Evaluating expressions
----------------------

To evaluate an expression pass it to ``curry.eval``.

    >>> print next(curry.eval(goal))
    S (S (S O))
    >>> print next(curry.eval(goal2))
    13

``curry.eval`` returns a generator that yields one value of the goal with each
invocation of ``next``.  The goal is evaluated lazily, meaning that each call
to ``next`` performs the minimum evaluation necessary to compute the next
value.

