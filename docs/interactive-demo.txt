============================
Using Sprite Python Bindings
============================

This introduction shows how to interact with the Sprite Curry system via its
Python interface.  It assumes familiarity with Curry.

To get started, invoke the Python executable found at $PREFIX/bin/python.  This
will automatically set up the PYTHONPATH environment variable, making Sprite
available.

The Sprite Curry system is in the ``curry`` module.

  >>> import curry


Using Modules
=============

Curry modules can be loaded from files or defined dynamically.  This section
describes how to work with modules in Sprite.


Loading Curry modules
---------------------

Curry code can be imported into Python using the Python import mechanism.  The
search path for Curry modules can be found in the list variable ``curry.path``.
Its initial value comes by splitting the CURRYPATH environment variable on
colons.  Therefore, one way to load the ``Peano`` module found in the same
directory as this tutorial would be to add this directory to CURRYPATH before
starting Python.  Alternatively, if Python has already been started in this
directory, then the search path can be updated as follows:

    >>> curry.path[:] = ['.']

(Be sure to update the list object rather than rebind the ``curry.path``
variable.  So, use slice assignment, as shown above, or the ``list.insert``
method.)

To import a Curry module, import it relative to ``curry.lib``.

    >>> from curry.lib import Peano

This searches each path in ``curry.path``, in order, until it finds a file
named ``Peano.curry``.

Curry definitions can also be created dynamically by passing a string to
``curry.compile``.  This has the same effect as importing a Curry source file
with the same content.

    >>> Fib = curry.compile(
    ...   '''
    ...   fib n | n < 3 = 1
    ...         | True  = (fib (n-1)) + (fib (n-2))
    ...   '''
    ... )

Symbols loaded in this way are placed in the special module named ``_interactive_``.


Building expressions
--------------------

A loaded Curry module provides a set of definitions.  These appear as
attributes.

    >>> Peano.S
    <curry constructor 'Peano.S'>
    >>> Peano.O
    <curry constructor 'Peano.O'>
    >>> Fib.fib
    <curry function '_interactive_.fib'>

To evaluate Curry code, it is first necessary to build a goal.  The function
``curry.expr`` builds Curry expressions.  There are two ways to use it: the
first is to pass a string containing Curry code.

    >>> goal = curry.expr('add (S (S O)) (S O)')
    >>> print goal
    add (S (S O)) (S O)

The second is to pass ``curry.expr`` a list of Curry symbols and literal
values.

    >>> goal2 = curry.expr([Fib.fib, 7])
    >>> print goal2
    fib 7

Nested expressions can be specified with nested lists:

    >>> print curry.expr([Peano.S, [Peano.S, Peano.O]])
    S (S O)

Curry expressions have so far been shown using their string, or ``str``,
representation.  The representation, or ``repr``, provides more insight into
the structure.  (If you are unfamiliar with the difference between these,
consult the Python documentation.)  The following shows the representation of a
Curry expression:

    >>> print repr(goal2)
    <fib <Int 7>>

Each node is now enclosed in angle brackets and node labels are shown.  Every
angle-bracket-enclosed node specifier is either a label followed by zero or
more successors or a literal integer, floating-point number, or character.  The
arguments following a label can be built-ins or angle-enclosed node specifiers.
There are no special rules for formatting lists, tuples, or strings.  In this
above example, we can clearly see that the argument to ``fib`` is a boxed
integer, since the constructor ``Int`` appears before the integer literal
``7``.


Evaluating expressions
----------------------

To evaluate an expression pass it to ``curry.eval``.

    >>> print next(curry.eval(goal))
    S (S (S O))
    >>> print next(curry.eval(goal2))
    13

``curry.eval`` returns a generator that yields one value of the goal with each
invocation of ``next``.  The goal is evaluated lazily, meaning that each call
to ``next`` performs the minimum evaluation necessary to compute the next
value.

