interface Prelude where {
infix 4 ==;
infix 4 /=;
infixl 7 /;
infixl 7 `div`;
infixl 7 `mod`;
infixl 7 `quot`;
infixl 7 `rem`;
infixl 1 >>=;
infixl 1 >>;
infixl 6 +;
infixl 6 -;
infixl 7 *;
infix 4 <=;
infix 4 >=;
infix 4 <;
infix 4 >;
infixr 0 $;
infixr 0 $!;
infixr 0 $!!;
infixr 0 $#;
infixr 0 $##;
infixr 0 &;
infixr 3 &&;
infixr 0 &>;
infixr 5 ++;
infixr 9 .;
infix 4 =:<=;
infix 4 =:=;
infixr 0 ?;
infix 4 `elem`;
infix 4 `notElem`;
infixr 0 `seq`;
infixr 2 ||;
data Bool = False | True;
class Bounded a {
  minBound :: a;
  maxBound :: a
};
data Char;
type DET a = a;
data Either a b = Left a | Right b;
class Enum a {
  succ 0 :: a -> a;
  pred 0 :: a -> a;
  toEnum :: Int -> a;
  fromEnum :: a -> Int;
  enumFrom 1 :: a -> [a];
  enumFromThen 2 :: a -> a -> [a];
  enumFromTo 2 :: a -> a -> [a];
  enumFromThenTo 3 :: a -> a -> a -> [a]
};
class Eq a {
  (==) 2 :: a -> a -> Bool;
  (/=) 2 :: a -> a -> Bool
};
data Float;
class Num a => Fractional a {
  (/) 2 :: a -> a -> a;
  recip 1 :: a -> a;
  fromFloat :: Float -> a
};
class (Functor :: * -> *) a {
  fmap :: (b -> c) -> a b -> a c
};
data IO a;
data IOError
  = IOError [Char]
  | UserError [Char]
  | FailError [Char]
  | NondetError [Char];
data Int;
class Real a => Integral a {
  div 2 :: a -> a -> a;
  mod 2 :: a -> a -> a;
  quot 2 :: a -> a -> a;
  rem 2 :: a -> a -> a;
  divMod :: a -> a -> (a, a);
  quotRem :: a -> a -> (a, a)
};
data Maybe a = Nothing | Just a;
class (Monad :: * -> *) a {
  (>>=) :: a b -> (b -> a c) -> a c;
  (>>) 2 :: a b -> a c -> a c;
  return :: b -> a b;
  fail 1 :: [Char] -> a b
};
class Num a {
  (+) :: a -> a -> a;
  (-) 2 :: a -> a -> a;
  (*) :: a -> a -> a;
  negate 1 :: a -> a;
  abs :: a -> a;
  signum :: a -> a;
  fromInt :: Int -> a
};
class Eq a => Ord a {
  compare 2 :: a -> a -> Ordering;
  (<=) 2 :: a -> a -> Bool;
  (>=) 2 :: a -> a -> Bool;
  (<) 2 :: a -> a -> Bool;
  (>) 2 :: a -> a -> Bool;
  min 2 :: a -> a -> a;
  max 2 :: a -> a -> a
};
data Ordering = LT | EQ | GT;
class Read a {
  readsPrec :: Int -> [Char] -> [(a, [Char])];
  readList 0 :: [Char] -> [([a], [Char])]
};
type ReadS a = [Char] -> [(a, [Char])];
class (Num a, Ord a) => Real a {
};
class Show a {
  show 1 :: a -> [Char];
  showsPrec 3 :: Int -> a -> [Char] -> [Char];
  showList 2 :: [a] -> [Char] -> [Char]
};
type ShowS = [Char] -> [Char];
type String = [Char];
type Success = Bool;
(!!) 2 :: [a] -> Int -> a;
($) 2 :: (a -> b) -> a -> b;
($!) 2 :: (a -> b) -> a -> b;
($!!) 2 :: (a -> b) -> a -> b;
($#) 2 :: (a -> b) -> a -> b;
($##) 2 :: (a -> b) -> a -> b;
(&) 2 :: Bool -> Bool -> Bool;
(&&) 2 :: Bool -> Bool -> Bool;
(&>) 2 :: Bool -> a -> a;
(++) 2 :: [a] -> [a] -> [a];
(.) 2 :: (a -> b) -> (c -> a) -> c -> b;
(=:<=) 2 :: a -> a -> Bool;
(=:=) 2 :: a -> a -> Bool;
(?) 2 :: a -> a -> a;
PEVAL 1 :: a -> a;
all 1 :: (a -> Bool) -> [a] -> Bool;
and 0 :: [Bool] -> Bool;
any 1 :: (a -> Bool) -> [a] -> Bool;
anyOf 0 :: [a] -> a;
appendFile 2 :: [Char] -> [Char] -> IO ();
apply 2 :: (a -> b) -> a -> b;
asTypeOf 0 :: a -> a -> a;
boundedEnumFrom 1 :: (Bounded a, Enum a) => a -> [a];
boundedEnumFromThen 2 :: (Bounded a, Enum a) => a -> a -> [a];
break 1 :: (a -> Bool) -> [a] -> ([a], [a]);
catch 2 :: IO a -> (IOError -> IO a) -> IO a;
chr 1 :: Int -> Char;
concat 1 :: [[a]] -> [a];
concatMap 1 :: (a -> [b]) -> [a] -> [b];
cond 2 :: Bool -> a -> a;
const 2 :: a -> b -> a;
curry 3 :: ((a, b) -> c) -> a -> b -> c;
doSolve 1 :: Bool -> IO ();
done 0 :: IO ();
drop 2 :: Int -> [a] -> [a];
dropWhile 2 :: (a -> Bool) -> [a] -> [a];
either 3 :: (a -> b) -> (c -> b) -> Either a c -> b;
elem 1 :: Eq a => a -> [a] -> Bool;
ensureNotFree 1 :: a -> a;
ensureSpine 1 :: [a] -> [a];
enumFromThenTo_ 3 :: Int -> Int -> Int -> [Int];
enumFromThen_ 2 :: Int -> Int -> [Int];
enumFromTo_ 2 :: Int -> Int -> [Int];
enumFrom_ 1 :: Int -> [Int];
error 1 :: [Char] -> a;
failed 0 :: a;
filter 2 :: (a -> Bool) -> [a] -> [a];
flip 3 :: (a -> b -> c) -> b -> a -> c;
foldIO 3 :: (a -> b -> IO a) -> a -> [b] -> IO a;
foldM 3 :: Monad c => (a -> b -> c a) -> a -> [b] -> c a;
foldl 3 :: (a -> b -> a) -> a -> [b] -> a;
foldl1 2 :: (a -> a -> a) -> [a] -> a;
foldr 3 :: (a -> b -> b) -> b -> [a] -> b;
foldr1 2 :: (a -> a -> a) -> [a] -> a;
forIO 2 :: [a] -> (a -> IO b) -> IO [b];
forIO_ 2 :: [a] -> (a -> IO b) -> IO ();
forM 2 :: Monad b => [a] -> (a -> b c) -> b [c];
forM_ 2 :: Monad b => [a] -> (a -> b c) -> b ();
fst 1 :: (a, b) -> a;
getChar 0 :: IO Char;
getLine 0 :: IO [Char];
groundNormalForm 1 :: a -> a;
head 1 :: [a] -> a;
id 1 :: a -> a;
if_then_else 3 :: Bool -> a -> a -> a;
ioError 1 :: IOError -> IO a;
iterate 2 :: (a -> a) -> a -> [a];
length 1 :: [a] -> Int;
lex 1 :: [Char] -> [([Char], [Char])];
liftIO 2 :: (a -> b) -> IO a -> IO b;
liftM 2 :: Monad c => (a -> b) -> c a -> c b;
liftM2 3 :: Monad d => (a -> b -> c) -> d a -> d b -> d c;
lines 1 :: [Char] -> [[Char]];
lookup 2 :: Eq a => a -> [(a, b)] -> Maybe b;
map 2 :: (a -> b) -> [a] -> [b];
mapIO 1 :: (a -> IO b) -> [a] -> IO [b];
mapIO_ 1 :: (a -> IO b) -> [a] -> IO ();
mapM 1 :: Monad b => (a -> b c) -> [a] -> b [c];
mapM_ 1 :: Monad b => (a -> b c) -> [a] -> b ();
maybe 3 :: a -> (b -> a) -> Maybe b -> a;
negateFloat 1 :: Float -> Float;
negate_ 1 :: Int -> Int;
normalForm 1 :: a -> a;
not 1 :: Bool -> Bool;
notElem 1 :: Eq a => a -> [a] -> Bool;
null 1 :: [a] -> Bool;
or 0 :: [Bool] -> Bool;
ord 1 :: Char -> Int;
otherwise 0 :: Bool;
print 1 :: Show a => a -> IO ();
putChar 1 :: Char -> IO ();
putStr 1 :: [Char] -> IO ();
putStrLn 1 :: [Char] -> IO ();
read 1 :: Read a => [Char] -> a;
readFile 1 :: [Char] -> IO [Char];
readParen
2
::
Bool -> ([Char] -> [(a, [Char])]) -> [Char] -> [(a, [Char])];
reads 0 :: Read a => [Char] -> [(a, [Char])];
repeat 1 :: a -> [a];
replicate 2 :: Int -> a -> [a];
reverse 0 :: [a] -> [a];
seq 2 :: a -> b -> b;
sequence 0 :: Monad a => [a b] -> a [b];
sequenceIO 1 :: [IO a] -> IO [a];
sequenceIO_ 0 :: [IO a] -> IO ();
sequence_ 0 :: Monad a => [a b] -> a ();
showChar 2 :: Char -> [Char] -> [Char];
showError 1 :: IOError -> [Char];
showParen 2 :: Bool -> ([Char] -> [Char]) -> [Char] -> [Char];
showString 2 :: [Char] -> [Char] -> [Char];
shows 0 :: Show a => a -> [Char] -> [Char];
snd 1 :: (a, b) -> b;
solve 1 :: Bool -> Bool;
span 2 :: (a -> Bool) -> [a] -> ([a], [a]);
splitAt 2 :: Int -> [a] -> ([a], [a]);
success 0 :: Bool;
tail 1 :: [a] -> [a];
take 2 :: Int -> [a] -> [a];
takeWhile 2 :: (a -> Bool) -> [a] -> [a];
uncurry 2 :: (a -> b -> c) -> (a, b) -> c;
unknown 0 :: a;
unless 2 :: Bool -> IO () -> IO ();
unlessM 2 :: Monad a => Bool -> a () -> a ();
unlines 1 :: [[Char]] -> [Char];
until 3 :: (a -> Bool) -> (a -> a) -> a -> a;
unwords 1 :: [[Char]] -> [Char];
unzip 1 :: [(a, b)] -> ([a], [b]);
unzip3 1 :: [(a, b, c)] -> ([a], [b], [c]);
userError 1 :: [Char] -> IOError;
when 2 :: Bool -> IO () -> IO ();
whenM 2 :: Monad a => Bool -> a () -> a ();
words 1 :: [Char] -> [[Char]];
writeFile 2 :: [Char] -> [Char] -> IO ();
zip 2 :: [a] -> [b] -> [(a, b)];
zip3 3 :: [a] -> [b] -> [c] -> [(a, b, c)];
zipWith 3 :: (a -> b -> c) -> [a] -> [b] -> [c];
zipWith3 4 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d];
(||) 2 :: Bool -> Bool -> Bool;
instance Bounded () {
  maxBound 0;
  minBound 0
};
instance (Bounded a, Bounded b) => Bounded (a, b) {
  maxBound 0;
  minBound 0
};
instance (Bounded a, Bounded b, Bounded c) => Bounded (a, b, c) {
  maxBound 0;
  minBound 0
};
instance (Bounded a, Bounded b, Bounded c,
          Bounded d) => Bounded (a, b, c, d) {
  maxBound 0;
  minBound 0
};
instance (Bounded a, Bounded b, Bounded c, Bounded d,
          Bounded e) => Bounded (a, b, c, d, e) {
  maxBound 0;
  minBound 0
};
instance Bounded Bool {
  maxBound 0;
  minBound 0
};
instance Bounded Char {
  maxBound 0;
  minBound 0
};
instance Enum () {
  enumFromThenTo 3;
  enumFromTo 2;
  enumFromThen 2;
  enumFrom 1;
  fromEnum 1;
  toEnum 1;
  pred 1;
  succ 1
};
instance Enum Bool {
  enumFromThen 0;
  enumFrom 0;
  fromEnum 1;
  toEnum 1;
  pred 1;
  succ 1
};
instance Enum Char {
  enumFromThen 0;
  enumFrom 0;
  fromEnum 0;
  toEnum 0;
  pred 1;
  succ 1
};
instance Eq () {
  (==) 2
};
instance (Eq a, Eq b) => Eq (a, b) {
  (==) 2
};
instance (Eq a, Eq b, Eq c) => Eq (a, b, c) {
  (==) 2
};
instance (Eq a, Eq b, Eq c, Eq d) => Eq (a, b, c, d) {
  (==) 2
};
instance (Eq a, Eq b, Eq c, Eq d, Eq e) => Eq (a, b, c, d, e) {
  (==) 2
};
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f) => Eq (a, b, c, d, e,
                                                     f) {
  (==) 2
};
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g) => Eq (a, b, c,
                                                           d, e, f, g) {
  (==) 2
};
instance Eq a => Eq [a] {
  (==) 2
};
instance Eq Bool {
  (==) 2
};
instance Eq Char {
  (==) 2
};
instance (Eq a, Eq b) => Eq (Either a b) {
  (==) 2
};
instance Eq Float {
  (==) 2
};
instance Fractional Float {
  fromFloat 1;
  recip 1;
  (/) 2
};
instance Functor [] {
  fmap 0
};
instance Eq IOError {
  (==) 2
};
instance Enum Int {
  enumFromThenTo 0;
  enumFromThen 0;
  enumFromTo 0;
  enumFrom 0;
  fromEnum 1;
  toEnum 1;
  pred 1;
  succ 1
};
instance Eq Int {
  (==) 2
};
instance Integral Int {
  quotRem 2;
  divMod 2
};
instance Eq a => Eq (Maybe a) {
  (==) 2
};
instance Monad [] {
  fail 1;
  return 1;
  (>>=) 2
};
instance Monad IO {
  return 1;
  (>>) 2;
  (>>=) 2
};
instance Monad Maybe {
  fail 1;
  return 0;
  (>>=) 2
};
instance Num Float {
  fromInt 1;
  signum 1;
  abs 1;
  negate 1;
  (*) 2;
  (-) 2;
  (+) 2
};
instance Num Int {
  fromInt 1;
  signum 1;
  abs 1;
  negate 1;
  (*) 2;
  (-) 2;
  (+) 2
};
instance Ord () {
  (<=) 2
};
instance (Ord a, Ord b) => Ord (a, b) {
  (<=) 2
};
instance (Ord a, Ord b, Ord c) => Ord (a, b, c) {
  (<=) 2
};
instance (Ord a, Ord b, Ord c, Ord d) => Ord (a, b, c, d) {
  (<=) 2
};
instance (Ord a, Ord b, Ord c, Ord d, Ord e) => Ord (a, b, c, d,
                                                     e) {
  (<=) 2
};
instance Ord a => Ord [a] {
  (<=) 2
};
instance Ord Bool {
  (<=) 2
};
instance Ord Char {
  (<=) 2
};
instance (Ord a, Ord b) => Ord (Either a b) {
  (<=) 2
};
instance Ord Float {
  (<=) 2
};
instance Ord Int {
  (<=) 2
};
instance Ord a => Ord (Maybe a) {
  (<=) 2
};
instance Bounded Ordering {
  maxBound 0;
  minBound 0
};
instance Enum Ordering {
  enumFromThen 0;
  enumFrom 0;
  fromEnum 1;
  toEnum 1;
  pred 1;
  succ 1
};
instance Eq Ordering {
  (==) 2
};
instance Ord Ordering {
  (<=) 2
};
instance Read () {
  readsPrec 1
};
instance (Read a, Read b) => Read (a, b) {
  readsPrec 1
};
instance (Read a, Read b, Read c) => Read (a, b, c) {
  readsPrec 1
};
instance (Read a, Read b, Read c, Read d) => Read (a, b, c, d) {
  readsPrec 1
};
instance (Read a, Read b, Read c, Read d, Read e) => Read (a, b, c,
                                                           d, e) {
  readsPrec 1
};
instance Read a => Read [a] {
  readsPrec 1
};
instance Read Bool {
  readsPrec 2
};
instance Read Char {
  readList 1;
  readsPrec 1
};
instance (Read a, Read b) => Read (Either a b) {
  readsPrec 2
};
instance Read Float {
  readsPrec 1
};
instance Read IOError {
  readsPrec 2
};
instance Read Int {
  readsPrec 1
};
instance Read a => Read (Maybe a) {
  readsPrec 2
};
instance Read Ordering {
  readsPrec 2
};
instance Real Float {
};
instance Real Int {
};
instance Show () {
  showsPrec 2
};
instance (Show a, Show b) => Show (a, b) {
  showsPrec 2
};
instance (Show a, Show b, Show c) => Show (a, b, c) {
  showsPrec 2
};
instance (Show a, Show b, Show c, Show d) => Show (a, b, c, d) {
  showsPrec 2
};
instance (Show a, Show b, Show c, Show d, Show e) => Show (a, b, c,
                                                           d, e) {
  showsPrec 2
};
instance Show a => Show [a] {
  showsPrec 1
};
instance Show Bool {
  showsPrec 2
};
instance Show Char {
  showList 1;
  showsPrec 2
};
instance (Show a, Show b) => Show (Either a b) {
  showsPrec 2
};
instance Show Float {
  showsPrec 0
};
instance Show IOError {
  showsPrec 2
};
instance Show Int {
  showsPrec 0
};
instance Show a => Show (Maybe a) {
  showsPrec 2
};
instance Show Ordering {
  showsPrec 2
}
}