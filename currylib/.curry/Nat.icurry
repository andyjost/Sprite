interface Nat where {
import Prelude;
data BinInt = Neg Nat | Zero | Pos Nat;
data Nat = IHi | O Nat | I Nat;
(*#) 2 :: BinInt -> BinInt -> BinInt;
(*^) 2 :: Nat -> Nat -> Nat;
(+#) 2 :: BinInt -> BinInt -> BinInt;
(+^) 2 :: Nat -> Nat -> Nat;
(-#) 2 :: BinInt -> BinInt -> BinInt;
(-^) 2 :: Nat -> Nat -> BinInt;
cmpInteger 2 :: BinInt -> BinInt -> Prelude.Ordering;
cmpNat 2 :: Nat -> Nat -> Prelude.Ordering;
dec 1 :: BinInt -> BinInt;
div2 1 :: Nat -> Nat;
divInteger 2 :: BinInt -> BinInt -> BinInt;
divModInteger 2 :: BinInt -> BinInt -> (BinInt, BinInt);
inc 1 :: BinInt -> BinInt;
lteqInteger 2 :: BinInt -> BinInt -> Prelude.Bool;
mod2 1 :: Nat -> BinInt;
modInteger 2 :: BinInt -> BinInt -> BinInt;
mult2 1 :: BinInt -> BinInt;
neg 1 :: BinInt -> BinInt;
pred 1 :: Nat -> Nat;
quotInteger 2 :: BinInt -> BinInt -> BinInt;
quotRemInteger 2 :: BinInt -> BinInt -> (BinInt, BinInt);
quotRemNat 2 :: Nat -> Nat -> (BinInt, BinInt);
remInteger 2 :: BinInt -> BinInt -> BinInt;
succ 1 :: Nat -> Nat;
instance Prelude.Eq Nat {
  (==) 2
};
hiding data Prelude.Ordering;
hiding data Prelude.Bool;
hiding class Prelude.Eq a;
instance Prelude.Eq () {
  (==) 2
} {-# MODULE Prelude #-};
instance (Prelude.Eq a, Prelude.Eq b) => Prelude.Eq (a, b) {
  (==) 2
} {-# MODULE Prelude #-};
instance (Prelude.Eq a, Prelude.Eq b,
          Prelude.Eq c) => Prelude.Eq (a, b, c) {
  (==) 2
} {-# MODULE Prelude #-};
instance (Prelude.Eq a, Prelude.Eq b, Prelude.Eq c,
          Prelude.Eq d) => Prelude.Eq (a, b, c, d) {
  (==) 2
} {-# MODULE Prelude #-};
instance (Prelude.Eq a, Prelude.Eq b, Prelude.Eq c, Prelude.Eq d,
          Prelude.Eq e) => Prelude.Eq (a, b, c, d, e) {
  (==) 2
} {-# MODULE Prelude #-};
instance (Prelude.Eq a, Prelude.Eq b, Prelude.Eq c, Prelude.Eq d,
          Prelude.Eq e, Prelude.Eq f) => Prelude.Eq (a, b, c, d, e, f) {
  (==) 2
} {-# MODULE Prelude #-};
instance (Prelude.Eq a, Prelude.Eq b, Prelude.Eq c, Prelude.Eq d,
          Prelude.Eq e, Prelude.Eq f, Prelude.Eq g) => Prelude.Eq (a, b, c,
                                                                   d, e, f, g) {
  (==) 2
} {-# MODULE Prelude #-};
instance Prelude.Eq a => Prelude.Eq [a] {
  (==) 2
} {-# MODULE Prelude #-};
instance Prelude.Eq Prelude.Bool {
  (==) 2
} {-# MODULE Prelude #-};
instance Prelude.Eq Prelude.Char {
  (==) 2
} {-# MODULE Prelude #-};
instance (Prelude.Eq a,
          Prelude.Eq b) => Prelude.Eq (Prelude.Either a b) {
  (==) 2
} {-# MODULE Prelude #-};
instance Prelude.Eq Prelude.Float {
  (==) 2
} {-# MODULE Prelude #-};
instance Prelude.Eq Prelude.IOError {
  (==) 2
} {-# MODULE Prelude #-};
instance Prelude.Eq Prelude.Int {
  (==) 2
} {-# MODULE Prelude #-};
instance Prelude.Eq a => Prelude.Eq (Prelude.Maybe a) {
  (==) 2
} {-# MODULE Prelude #-};
instance Prelude.Eq Prelude.Ordering {
  (==) 2
} {-# MODULE Prelude #-};
hiding data Prelude.Char;
hiding data Prelude.Either a b;
hiding data Prelude.Float;
hiding data Prelude.IOError;
hiding data Prelude.Int;
hiding data Prelude.Maybe a
}